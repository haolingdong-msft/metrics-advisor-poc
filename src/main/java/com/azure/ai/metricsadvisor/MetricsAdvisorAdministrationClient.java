// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.ai.metricsadvisor;

import com.azure.ai.metricsadvisor.administration.models.DataFeed;
import com.azure.ai.metricsadvisor.administration.models.ListDataFeedOptions;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;

/** Initializes a new instance of the synchronous MetricsAdvisorClient type. */
@ServiceClient(builder = MetricsAdvisorAdministrationClientBuilder.class)
public final class MetricsAdvisorAdministrationClient {

    private static final String METRICS_ADVISOR_TRACING_NAMESPACE_VALUE = "Microsoft.CognitiveServices";

    private final ClientLogger logger = new ClientLogger(MetricsAdvisorAdministrationAsyncClient.class);

    /**
     * Update anomaly alerting configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateAnomalyAlertingConfigurationWithResponse(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return this.client
                .updateAnomalyAlertingConfigurationWithResponse(configurationId, body, requestOptions)
                .block();
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteAnomalyAlertingConfigurationWithResponse(
            String configurationId, RequestOptions requestOptions) {
        return this.client.deleteAnomalyAlertingConfigurationWithResponse(configurationId, requestOptions).block();
    }

    /**
     * Create anomaly alerting configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body anomaly alerting configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createAnomalyAlertingConfigurationWithResponse(
            BinaryData body, RequestOptions requestOptions) {
        return this.client.createAnomalyAlertingConfigurationWithResponse(body, requestOptions).block();
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getAnomalyDetectionConfigurationWithResponse(
            String configurationId, RequestOptions requestOptions) {
        return this.client.getAnomalyDetectionConfigurationWithResponse(configurationId, requestOptions).block();
    }

    /**
     * Update anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String
     *     description: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: Integer
     *                 minRatio: Double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: Double
     *             shiftPoint: Integer
     *             withinRange: Boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: {
     *                 sensitivity: double
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: {
     *                     minNumber: int
     *                     minRatio: double
     *                 }
     *             }
     *             hardThresholdCondition: {
     *                 lowerBound: Double
     *                 upperBound: Double
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: (recursive schema, see suppressCondition above)
     *             }
     *             changeThresholdCondition: {
     *                 changePercentage: double
     *                 shiftPoint: int
     *                 withinRange: boolean
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: (recursive schema, see suppressCondition above)
     *             }
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateAnomalyDetectionConfigurationWithResponse(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return this.client
                .updateAnomalyDetectionConfigurationWithResponse(configurationId, body, requestOptions)
                .block();
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteAnomalyDetectionConfigurationWithResponse(
            String configurationId, RequestOptions requestOptions) {
        return this.client.deleteAnomalyDetectionConfigurationWithResponse(configurationId, requestOptions).block();
    }

    /**
     * Create anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body anomaly detection configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createAnomalyDetectionConfigurationWithResponse(
            BinaryData body, RequestOptions requestOptions) {
        return this.client.createAnomalyDetectionConfigurationWithResponse(body, requestOptions).block();
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyAlertingConfigurationId: String
     *             name: String
     *             description: String
     *             crossMetricsOperator: String(AND/OR/XOR)
     *             splitAlertByDimensions: [
     *                 String
     *             ]
     *             hookIds: [
     *                 String
     *             ]
     *             metricAlertingConfigurations: [
     *                 {
     *                     anomalyDetectionConfigurationId: String
     *                     anomalyScopeType: String(All/Dimension/TopN)
     *                     negationOperation: Boolean
     *                     dimensionAnomalyScope: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     topNAnomalyScope: {
     *                         top: int
     *                         period: int
     *                         minTopCount: int
     *                     }
     *                     severityFilter: {
     *                         minAlertSeverity: String(Low/Medium/High)
     *                         maxAlertSeverity: String(Low/Medium/High)
     *                     }
     *                     snoozeFilter: {
     *                         autoSnooze: int
     *                         snoozeScope: String(Metric/Series)
     *                         onlyForSuccessive: boolean
     *                     }
     *                     valueFilter: {
     *                         lower: Double
     *                         upper: Double
     *                         direction: String(Both/Down/Up)
     *                         type: String(Value/Mean)
     *                         metricId: String
     *                         triggerForMissing: Boolean
     *                     }
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
            String configurationId, RequestOptions requestOptions) {
        return new PagedIterable<>(
                this.client.getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
                        configurationId, requestOptions));
    }

    /**
     * Create a new data source credential.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param body Create data source credential request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createCredentialWithResponse(BinaryData body, RequestOptions requestOptions) {
        return this.client.createCredentialWithResponse(body, requestOptions).block();
    }

    /**
     * List all credentials.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataSourceCredentialId: String
     *             dataSourceCredentialName: String
     *             dataSourceCredentialDescription: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listCredentials(RequestOptions requestOptions) {
        return new PagedIterable<>(this.client.listCredentials(requestOptions));
    }

    /**
     * Update a data source credential.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param credentialId Data source credential unique ID.
     * @param body Update data source credential request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateCredentialWithResponse(
            String credentialId, BinaryData body, RequestOptions requestOptions) {
        return this.client.updateCredentialWithResponse(credentialId, body, requestOptions).block();
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteCredentialWithResponse(String credentialId, RequestOptions requestOptions) {
        return this.client.deleteCredentialWithResponse(credentialId, requestOptions).block();
    }

    /**
     * Get a data source credential.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param credentialId Data source credential unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a data source credential along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialWithResponse(String credentialId, RequestOptions requestOptions) {
        return this.client.getCredentialWithResponse(credentialId, requestOptions).block();
    }

    /**
     * List all data feeds.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>dataFeedName</td><td>String</td><td>No</td><td>filter data feed by its name</td></tr>
     *     <tr><td>dataSourceType</td><td>String</td><td>No</td><td>filter data feed by its source type</td></tr>
     *     <tr><td>granularityName</td><td>String</td><td>No</td><td>filter data feed by its granularity</td></tr>
     *     <tr><td>status</td><td>String</td><td>No</td><td>filter data feed by its status</td></tr>
     *     <tr><td>creator</td><td>String</td><td>No</td><td>filter data feed by its creator</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             dataFeedName: String
     *             dataFeedDescription: String
     *             granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *             granularityAmount: Integer
     *             metrics: [
     *                 {
     *                     metricId: String
     *                     metricName: String
     *                     metricDisplayName: String
     *                     metricDescription: String
     *                 }
     *             ]
     *             dimension: [
     *                 {
     *                     dimensionName: String
     *                     dimensionDisplayName: String
     *                 }
     *             ]
     *             timestampColumn: String
     *             dataStartFrom: String
     *             startOffsetInSeconds: Long
     *             maxConcurrency: Integer
     *             minRetryIntervalInSeconds: Long
     *             stopRetryAfterInSeconds: Long
     *             needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *             rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *             rollUpColumns: [
     *                 String
     *             ]
     *             allUpIdentification: String
     *             fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *             fillMissingPointValue: Double
     *             viewMode: String(Private/Public)
     *             admins: [
     *                 String
     *             ]
     *             viewers: [
     *                 String
     *             ]
     *             isAdmin: Boolean
     *             creator: String
     *             status: String(Active/Paused)
     *             createdTime: String
     *             actionLinkTemplate: String
     *             authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *             credentialId: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listDataFeeds(RequestOptions requestOptions) {
        return new PagedIterable<>(this.client.listDataFeeds(requestOptions));
    }

    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataFeed> listDataFeeds() {
        return listDataFeeds(null, Context.NONE);
    }

    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataFeed> listDataFeeds(ListDataFeedOptions options, Context context) {
        return new PagedIterable<>(this.client.listDataFeeds(options, context));
    }

    /**
     * Create a new data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param body parameters to create a data feed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createDataFeedWithResponse(BinaryData body, RequestOptions requestOptions) {
        return this.client.createDataFeedWithResponse(body, requestOptions).block();
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataFeed createDataFeed(DataFeed dataFeed) {
        return createDataFeedWithResponse(dataFeed, Context.NONE).getValue();
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DataFeed> createDataFeedWithResponse(DataFeed dataFeed, Context context) {
        return this.client.createDataFeedWithResponse(dataFeed, context).block();
    }

    /**
     * Get a data feed by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a data feed by its id along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDataFeedByIdWithResponse(String dataFeedId, RequestOptions requestOptions) {
        return this.client.getDataFeedByIdWithResponse(dataFeedId, requestOptions).block();
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataFeed getDataFeed(String dataFeedId) {
        return getDataFeedWithResponse(dataFeedId, Context.NONE).getValue();
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DataFeed> getDataFeedWithResponse(String dataFeedId, Context context) {
        return this.client.getDataFeedWithResponse(dataFeedId, context).block();
    }

    /**
     * Update a data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     status: String(Active/Paused)
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateDataFeedWithResponse(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return this.client.updateDataFeedWithResponse(dataFeedId, body, requestOptions).block();
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataFeed updateDataFeed(DataFeed dataFeed) {
        return updateDataFeedWithResponse(dataFeed, Context.NONE).getValue();
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DataFeed> updateDataFeedWithResponse(DataFeed dataFeed, Context context) {
        return this.client.updateDataFeedWithResponse(dataFeed, context).block();
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDataFeedWithResponse(String dataFeedId, RequestOptions requestOptions) {
        return this.client.deleteDataFeedWithResponse(dataFeedId, requestOptions).block();
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDataFeed(String dataFeedId) {
        deleteDataFeedWithResponse(dataFeedId, Context.NONE);
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDataFeedWithResponse(String dataFeedId, Context context) {
        return this.client.deleteDataFeedWithResponse(dataFeedId, context).block();
    }

    /**
     * List all hooks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>hookName</td><td>String</td><td>No</td><td>filter hook by its name</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             hookId: String
     *             hookName: String
     *             description: String
     *             externalLink: String
     *             admins: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listHooks(RequestOptions requestOptions) {
        return new PagedIterable<>(this.client.listHooks(requestOptions));
    }

    /**
     * Create a new hook.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param body Create hook request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createHookWithResponse(BinaryData body, RequestOptions requestOptions) {
        return this.client.createHookWithResponse(body, requestOptions).block();
    }

    /**
     * Get a hook by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param hookId Hook unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a hook by its id along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getHookWithResponse(String hookId, RequestOptions requestOptions) {
        return this.client.getHookWithResponse(hookId, requestOptions).block();
    }

    /**
     * Update a hook.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateHookWithResponse(String hookId, BinaryData body, RequestOptions requestOptions) {
        return this.client.updateHookWithResponse(hookId, body, requestOptions).block();
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteHookWithResponse(String hookId, RequestOptions requestOptions) {
        return this.client.deleteHookWithResponse(hookId, requestOptions).block();
    }

    /**
     * Get data ingestion status by data feed.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String(NotStarted/Scheduled/Running/Succeeded/Failed/NoData/Error/Paused)
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data ingestion status by data feed as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getDataFeedIngestionStatus(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return new PagedIterable<>(this.client.getDataFeedIngestionStatus(dataFeedId, body, requestOptions));
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> resetDataFeedIngestionStatusWithResponse(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return this.client.resetDataFeedIngestionStatusWithResponse(dataFeedId, body, requestOptions).block();
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     latestSuccessTimestamp: String
     *     latestActiveTimestamp: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data last success ingestion job timestamp by data feed along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getIngestionProgressWithResponse(String dataFeedId, RequestOptions requestOptions) {
        return this.client.getIngestionProgressWithResponse(dataFeedId, requestOptions).block();
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             name: String
     *             description: String
     *             metricId: String
     *             wholeMetricConfiguration: {
     *                 conditionOperator: String(AND/OR)
     *                 smartDetectionCondition: {
     *                     sensitivity: double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: {
     *                         minNumber: int
     *                         minRatio: double
     *                     }
     *                 }
     *                 hardThresholdCondition: {
     *                     lowerBound: Double
     *                     upperBound: Double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *                 changeThresholdCondition: {
     *                     changePercentage: double
     *                     shiftPoint: int
     *                     withinRange: boolean
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *             }
     *             dimensionGroupOverrideConfigurations: [
     *                 {
     *                     group: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *             seriesOverrideConfigurations: [
     *                 {
     *                     series: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getAnomalyDetectionConfigurationsByMetric(
            String metricId, RequestOptions requestOptions) {
        return new PagedIterable<>(this.client.getAnomalyDetectionConfigurationsByMetric(metricId, requestOptions));
    }

    /**
     * Initializes an instance of MetricsAdvisorAdministrationClient class.
     *
     * @param client the async client.
     */
    @Generated
    MetricsAdvisorAdministrationClient(MetricsAdvisorAdministrationAsyncClient client) {
        this.client = client;
    }

    @Generated private final MetricsAdvisorAdministrationAsyncClient client;
}
