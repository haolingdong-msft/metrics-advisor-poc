// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.ai.metricsadvisor.administration;

import com.azure.ai.metricsadvisor.MetricsAdvisorClientBuilder;
import com.azure.ai.metricsadvisor.administration.models.DataFeed;
import com.azure.ai.metricsadvisor.administration.models.DataFeedGranularity;
import com.azure.ai.metricsadvisor.administration.models.DataFeedIngestionSettings;
import com.azure.ai.metricsadvisor.administration.models.DataFeedMissingDataPointFillSettings;
import com.azure.ai.metricsadvisor.administration.models.DataFeedMissingDataPointFillType;
import com.azure.ai.metricsadvisor.administration.models.DataFeedOptions;
import com.azure.ai.metricsadvisor.administration.models.DataFeedRollupSettings;
import com.azure.ai.metricsadvisor.administration.models.DataFeedSchema;
import com.azure.ai.metricsadvisor.administration.models.ListDataFeedFilter;
import com.azure.ai.metricsadvisor.administration.models.ListDataFeedOptions;
import com.azure.ai.metricsadvisor.implementation.MetricsAdvisorClientImpl;
import com.azure.ai.metricsadvisor.implementation.models.DataFeedDetail;
import com.azure.ai.metricsadvisor.implementation.models.DataFeedDetailPatch;
import com.azure.ai.metricsadvisor.implementation.models.EntityStatus;
import com.azure.ai.metricsadvisor.implementation.models.FillMissingPointType;
import com.azure.ai.metricsadvisor.implementation.models.Granularity;
import com.azure.ai.metricsadvisor.implementation.models.NeedRollupEnum;
import com.azure.ai.metricsadvisor.implementation.models.RollUpMethod;
import com.azure.ai.metricsadvisor.implementation.models.ViewMode;
import com.azure.ai.metricsadvisor.implementation.util.DataFeedTransforms;
import com.azure.ai.metricsadvisor.implementation.util.PagedConverter;
import com.azure.ai.metricsadvisor.models.AnomalyAlert;
import com.azure.ai.metricsadvisor.models.ListAlertOptions;
import com.azure.ai.metricsadvisor.models.MetricsAdvisorError;
import com.azure.ai.metricsadvisor.models.MetricsAdvisorResponseException;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import reactor.core.publisher.Mono;

import java.time.OffsetDateTime;
import java.util.Objects;
import java.util.UUID;

import static com.azure.ai.metricsadvisor.administration.models.DataFeedGranularityType.CUSTOM;
import static com.azure.ai.metricsadvisor.implementation.util.Utility.parseOperationId;
import static com.azure.core.util.FluxUtil.monoError;
import static com.azure.core.util.FluxUtil.withContext;
import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;

/**
 * Initializes a new instance of the asynchronous MetricsAdvisorAdministrationAsyncClient type.
 */
@ServiceClient(builder = MetricsAdvisorAdministrationClientBuilder.class, isAsync = true)
public final class MetricsAdvisorAdministrationAsyncClient {
    private static final String METRICS_ADVISOR_TRACING_NAMESPACE_VALUE = "Microsoft.CognitiveServices";
    private final ClientLogger logger = new ClientLogger(MetricsAdvisorAdministrationAsyncClient.class);

    @Generated
    private final MetricsAdvisorClientImpl serviceClient;

    /**
     * Initializes an instance of MetricsAdvisorAdministrationAsyncClient client.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    MetricsAdvisorAdministrationAsyncClient(MetricsAdvisorClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }


    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createAnomalyAlertingConfigurationWithResponse(
            BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.createAnomalyAlertingConfigurationWithResponseAsync(body, requestOptions);
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     timeMode: String(AnomalyTime/CreatedTime/ModifiedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             alertId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body            query alerting result request.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAlertsByAnomalyAlertingConfiguration(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.getAlertsByAnomalyAlertingConfigurationAsync(configurationId, body, requestOptions);
    }

    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyAlert> listAlerts(
            String alertConfigurationId, OffsetDateTime startTime, OffsetDateTime endTime, ListAlertOptions options) {
        RequestOptions requestOptions = new RequestOptions();
        if (options.getMaxPageSize() != null) {
            requestOptions.addQueryParam("$maxpagesize", options.getMaxPageSize().toString());
        }
        if (options.getSkip() != null) {
            requestOptions.addQueryParam("$skip", options.getSkip().toString());
        }
        ObjectNode objectNode = JsonNodeFactory.instance.objectNode();
        if (startTime != null) {
            objectNode.put("startTime", startTime.toString());
        }
        if (endTime != null) {
            objectNode.put("endTime", endTime.toString());
        }
        if (options != null && options.getTimeMode() != null) {
            objectNode.put("timeMode", options.getTimeMode().toString());
        }
        BinaryData body = BinaryData.fromString(objectNode.toString());
        PagedFlux<BinaryData> response =
                this.getAlertsByAnomalyAlertingConfiguration(alertConfigurationId, body, requestOptions);
        return response.mapPage(binaryData -> binaryData.toObject(AnomalyAlert.class));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId         alert id.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAnomaliesFromAlertByAnomalyAlertingConfiguration(
            String configurationId, String alertId, RequestOptions requestOptions) {
        return this.serviceClient.getAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(
                configurationId, alertId, requestOptions);
    }

    /**
     * Query incidents under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId         alert id.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getIncidentsFromAlertByAnomalyAlertingConfiguration(
            String configurationId, String alertId, RequestOptions requestOptions) {
        return this.serviceClient.getIncidentsFromAlertByAnomalyAlertingConfigurationAsync(
                configurationId, alertId, requestOptions);
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAnomalyDetectionConfigurationWithResponse(
            String configurationId, RequestOptions requestOptions) {
        return this.serviceClient.getAnomalyDetectionConfigurationWithResponseAsync(configurationId, requestOptions);
    }

    /**
     * Update anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String
     *     description: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body            anomaly detection configuration.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateAnomalyDetectionConfigurationWithResponse(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.updateAnomalyDetectionConfigurationWithResponseAsync(
                configurationId, body, requestOptions);
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyDetectionConfigurationWithResponse(
            String configurationId, RequestOptions requestOptions) {
        return this.serviceClient.deleteAnomalyDetectionConfigurationWithResponseAsync(configurationId, requestOptions);
    }

    /**
     * Create anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body           anomaly detection configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createAnomalyDetectionConfigurationWithResponse(
            BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.createAnomalyDetectionConfigurationWithResponseAsync(body, requestOptions);
    }

    /**
     * Query all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyAlertingConfigurationId: String
     *             name: String
     *             description: String
     *             crossMetricsOperator: String(AND/OR/XOR)
     *             splitAlertByDimensions: [
     *                 String
     *             ]
     *             hookIds: [
     *                 String
     *             ]
     *             metricAlertingConfigurations: [
     *                 {
     *                     anomalyDetectionConfigurationId: String
     *                     anomalyScopeType: String(All/Dimension/TopN)
     *                     negationOperation: Boolean
     *                     dimensionAnomalyScope: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     topNAnomalyScope: {
     *                         top: int
     *                         period: int
     *                         minTopCount: int
     *                     }
     *                     severityFilter: {
     *                         minAlertSeverity: String(Low/Medium/High)
     *                         maxAlertSeverity: String(Low/Medium/High)
     *                     }
     *                     snoozeFilter: {
     *                         autoSnooze: int
     *                         snoozeScope: String(Metric/Series)
     *                         onlyForSuccessive: boolean
     *                     }
     *                     valueFilter: {
     *                         lower: Double
     *                         upper: Double
     *                         direction: String(Both/Down/Up)
     *                         type: String(Value/Mean)
     *                         metricId: String
     *                         triggerForMissing: Boolean
     *                     }
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationWithResponse(
            String configurationId, RequestOptions requestOptions) {
        return this.serviceClient.getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationWithResponseAsync(
                configurationId, requestOptions);
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     series: [
     *         {
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             timestampList: [
     *                 String
     *             ]
     *             valueList: [
     *                 double
     *             ]
     *             isAnomalyList: [
     *                 boolean
     *             ]
     *             periodList: [
     *                 int
     *             ]
     *             expectedValueList: [
     *                 double
     *             ]
     *             lowerBoundaryList: [
     *                 double
     *             ]
     *             upperBoundaryList: [
     *                 double
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body            query series detection result request.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getSeriesByAnomalyDetectionConfigurationWithResponse(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.getSeriesByAnomalyDetectionConfigurationWithResponseAsync(
                configurationId, body, requestOptions);
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *         severityFilter: {
     *             min: String(Low/Medium/High)
     *             max: String(Low/Medium/High)
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body            query detection anomaly result request.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAnomaliesByAnomalyDetectionConfiguration(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.getAnomaliesByAnomalyDetectionConfigurationAsync(
                configurationId, body, requestOptions);
    }

    /**
     * Query dimension values of anomalies.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     dimensionName: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body            query dimension values request.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.getDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(
                configurationId, body, requestOptions);
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body            query detection incident result request.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getIncidentsByAnomalyDetectionConfiguration(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.getIncidentsByAnomalyDetectionConfigurationAsync(
                configurationId, body, requestOptions);
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     *     <tr><td>token</td><td>String</td><td>No</td><td>the token for getting the next page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getIncidentsByAnomalyDetectionConfigurationNextPages(
            String configurationId, RequestOptions requestOptions) {
        return this.serviceClient.getIncidentsByAnomalyDetectionConfigurationNextPagesAsync(
                configurationId, requestOptions);
    }

    /**
     * Query root cause for incident.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             rootCause: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             path: [
     *                 String
     *             ]
     *             score: double
     *             description: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId      incident id.
     * @param requestOptions  The options to configure the HTTP request before HTTP client sends it.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponse(
            String configurationId, String incidentId, RequestOptions requestOptions) {
        return this.serviceClient.getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(
                configurationId, incidentId, requestOptions);
    }

    /**
     * Create a new data source credential.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param body           Create data source credential request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createCredentialWithResponse(BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.createCredentialWithResponseAsync(body, requestOptions);
    }

    /**
     * List all credentials.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataSourceCredentialId: String
     *             dataSourceCredentialName: String
     *             dataSourceCredentialDescription: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listCredentials(RequestOptions requestOptions) {
        return this.serviceClient.listCredentialsAsync(requestOptions);
    }

    /**
     * Update a data source credential.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param credentialId   Data source credential unique ID.
     * @param body           Update data source credential request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateCredentialWithResponse(
            String credentialId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.updateCredentialWithResponseAsync(credentialId, body, requestOptions);
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId   Data source credential unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCredentialWithResponse(String credentialId, RequestOptions requestOptions) {
        return this.serviceClient.deleteCredentialWithResponseAsync(credentialId, requestOptions);
    }

    /**
     * Get a data source credential.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param credentialId   Data source credential unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return a data source credential along with {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getCredentialWithResponse(String credentialId, RequestOptions requestOptions) {
        return this.serviceClient.getCredentialWithResponseAsync(credentialId, requestOptions);
    }

    /**
     * List all data feeds.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>dataFeedName</td><td>String</td><td>No</td><td>filter data feed by its name</td></tr>
     *     <tr><td>dataSourceType</td><td>String</td><td>No</td><td>filter data feed by its source type</td></tr>
     *     <tr><td>granularityName</td><td>String</td><td>No</td><td>filter data feed by its granularity</td></tr>
     *     <tr><td>status</td><td>String</td><td>No</td><td>filter data feed by its status</td></tr>
     *     <tr><td>creator</td><td>String</td><td>No</td><td>filter data feed by its creator</td></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             dataFeedName: String
     *             dataFeedDescription: String
     *             granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Secondly/Custom)
     *             granularityAmount: Integer
     *             metrics: [
     *                 {
     *                     metricId: String
     *                     metricName: String
     *                     metricDisplayName: String
     *                     metricDescription: String
     *                 }
     *             ]
     *             dimension: [
     *                 {
     *                     dimensionName: String
     *                     dimensionDisplayName: String
     *                 }
     *             ]
     *             timestampColumn: String
     *             dataStartFrom: String
     *             startOffsetInSeconds: Long
     *             maxConcurrency: Integer
     *             minRetryIntervalInSeconds: Long
     *             stopRetryAfterInSeconds: Long
     *             needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *             rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *             rollUpColumns: [
     *                 String
     *             ]
     *             allUpIdentification: String
     *             fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *             fillMissingPointValue: Double
     *             viewMode: String(Private/Public)
     *             admins: [
     *                 String
     *             ]
     *             viewers: [
     *                 String
     *             ]
     *             isAdmin: Boolean
     *             creator: String
     *             status: String(Active/Paused)
     *             createdTime: String
     *             actionLinkTemplate: String
     *             authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *             credentialId: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listDataFeeds(RequestOptions requestOptions) {
        return this.serviceClient.listDataFeedsAsync(requestOptions);
    }

    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataFeed> listDataFeeds() {
        return listDataFeeds(new ListDataFeedOptions());
    }

    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataFeed> listDataFeeds(ListDataFeedOptions listDataFeedOptions) {
        return listDataFeeds(listDataFeedOptions, Context.NONE);
    }

    PagedFlux<DataFeed> listDataFeeds(ListDataFeedOptions options, Context context) {
        options = options != null ? options : new ListDataFeedOptions();
        final ListDataFeedFilter dataFeedFilter =
                options.getListDataFeedFilter() != null ? options.getListDataFeedFilter() : new ListDataFeedFilter();
        final Context withTracing = context.addData(AZ_TRACING_NAMESPACE_KEY, METRICS_ADVISOR_TRACING_NAMESPACE_VALUE);

        RequestOptions requestOptions = new RequestOptions();
//        requestOptions.setContext(withTracing);
        if (dataFeedFilter.getName() != null) {
            requestOptions.addQueryParam("dataFeedName", dataFeedFilter.getName());
        }
        if (dataFeedFilter.getSourceType() != null) {
            requestOptions.addQueryParam("dataSourceType", dataFeedFilter.getSourceType().toString());
        }
        if (dataFeedFilter.getGranularityType() != null) {
            requestOptions.addQueryParam("granularityName", dataFeedFilter.getGranularityType().toString());
        }
        if (dataFeedFilter.getStatus() != null) {
            requestOptions.addQueryParam("status", dataFeedFilter.getStatus().toString());
        }
        if (dataFeedFilter.getCreator() != null) {
            requestOptions.addQueryParam("creator", dataFeedFilter.getCreator());
        }
        if (options.getSkip() != null) {
            requestOptions.addQueryParam("$skip", options.getSkip().toString(), true);
        }
        if (options.getMaxPageSize() != null) {
            requestOptions.addQueryParam("$maxpagesize", options.getMaxPageSize().toString(), true);
        }

        return PagedConverter.mapPage(listDataFeeds(requestOptions), response -> {
            DataFeedDetail dataFeedDetail = response.toObject(DataFeedDetail.class);
            return DataFeedTransforms.fromInner(dataFeedDetail);
        });
//                listDataFeeds(requestOptions).mapPage(response -> {
//            DataFeedDetail dataFeedDetail = response.toObject(DataFeedDetail.class);
//            return DataFeedTransforms.fromInner(dataFeedDetail);
//        });
    }

    /**
     * Create a new data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Secondly/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param body           parameters to create a data feed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createDataFeedWithResponse(BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.createDataFeedWithResponseAsync(body, requestOptions).onErrorMap(throwable -> {
            if (throwable instanceof HttpResponseException) {
                MetricsAdvisorError error = BinaryData.fromObject(((HttpResponseException) throwable).getValue()).toObject(MetricsAdvisorError.class);
                return new MetricsAdvisorResponseException(throwable.getMessage(), ((HttpResponseException) throwable).getResponse(), error);
            } else {
                return throwable;
            }
        });
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeed> createDataFeed(DataFeed dataFeed) {
        return createDataFeedWithResponse(dataFeed).flatMap(FluxUtil::toMono);
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeed>> createDataFeedWithResponse(DataFeed dataFeed) {
        try {
            return withContext(context -> createDataFeedWithResponse(dataFeed, context));
        } catch (RuntimeException ex) {
            return monoError(logger, ex);
        }
    }

    Mono<Response<DataFeed>> createDataFeedWithResponse(DataFeed dataFeed, Context context) {

        Objects.requireNonNull(dataFeed, "'dataFeed' is required and cannot be null.");
        Objects.requireNonNull(dataFeed.getSource(), "'dataFeedSource' is required and cannot be null.");
        Objects.requireNonNull(dataFeed.getName(), "'dataFeedName' cannot be null or empty.");

        final DataFeedSchema dataFeedSchema = dataFeed.getSchema();
        final DataFeedGranularity dataFeedGranularity = dataFeed.getGranularity();
        final DataFeedIngestionSettings dataFeedIngestionSettings = dataFeed.getIngestionSettings();

        if (dataFeedSchema == null) {
            throw logger.logExceptionAsError(
                    new NullPointerException("'dataFeedSchema.metrics' cannot be null or empty."));
        } else {
            Objects.requireNonNull(dataFeedSchema.getMetrics(),
                    "'dataFeedSchema.metrics' cannot be null or empty.");
        }

        if (dataFeedGranularity == null) {
            throw logger.logExceptionAsError(
                    new NullPointerException("'dataFeedGranularity.granularityType' is required and cannot be null."));

        } else {
            Objects.requireNonNull(dataFeedGranularity.getGranularityType(),
                    "'dataFeedGranularity.granularityType' is required.");
            if (CUSTOM.equals(dataFeedGranularity.getGranularityType())) {
                Objects.requireNonNull(dataFeedGranularity.getCustomGranularityValue(),
                        "'dataFeedGranularity.customGranularityValue' is required when granularity type is CUSTOM");
            }
        }

        if (dataFeedIngestionSettings == null) {
            throw logger.logExceptionAsError(
                    new NullPointerException(
                            "'dataFeedIngestionSettings.ingestionStartTime' is required and cannot be null."));
        } else {
            Objects.requireNonNull(dataFeedIngestionSettings.getIngestionStartTime(),
                    "'dataFeedIngestionSettings.ingestionStartTime' is required and cannot be null.");
        }

        final DataFeedOptions finalDataFeedOptions = dataFeed.getOptions() == null
                ? new DataFeedOptions() : dataFeed.getOptions();
        final DataFeedRollupSettings dataFeedRollupSettings = finalDataFeedOptions.getRollupSettings() == null
                ? new DataFeedRollupSettings() : finalDataFeedOptions.getRollupSettings();
        final DataFeedMissingDataPointFillSettings dataFeedMissingDataPointFillSettings =
                finalDataFeedOptions.getMissingDataPointFillSettings() == null
                        ? new DataFeedMissingDataPointFillSettings() : finalDataFeedOptions.getMissingDataPointFillSettings();
        final Context withTracing = context.addData(AZ_TRACING_NAMESPACE_KEY, METRICS_ADVISOR_TRACING_NAMESPACE_VALUE);

        DataFeedDetail dataFeedDetail = DataFeedTransforms.toDataFeedDetailSource(dataFeed.getSource())
                .setDataFeedName(dataFeed.getName())
                .setDataFeedDescription(finalDataFeedOptions.getDescription())
                .setGranularityName(Granularity.fromString(dataFeedGranularity.getGranularityType() == null
                        ? null : dataFeedGranularity.getGranularityType().toString()))
                .setGranularityAmount(dataFeedGranularity.getCustomGranularityValue())
                .setDimension(DataFeedTransforms.toInnerDimensionsListForCreate(dataFeedSchema.getDimensions()))
                .setMetrics(DataFeedTransforms.toInnerMetricsListForCreate(dataFeedSchema.getMetrics()))
                .setTimestampColumn(dataFeedSchema.getTimestampColumn())
                .setDataStartFrom(dataFeedIngestionSettings.getIngestionStartTime())
                .setStartOffsetInSeconds(dataFeedIngestionSettings.getIngestionStartOffset() == null
                        ? null : dataFeedIngestionSettings.getIngestionStartOffset().getSeconds())
                .setMaxConcurrency(dataFeedIngestionSettings.getDataSourceRequestConcurrency())
                .setStopRetryAfterInSeconds(dataFeedIngestionSettings.getStopRetryAfter() == null
                        ? null : dataFeedIngestionSettings.getStopRetryAfter().getSeconds())
                .setMinRetryIntervalInSeconds(dataFeedIngestionSettings.getIngestionRetryDelay() == null
                        ? null : dataFeedIngestionSettings.getIngestionRetryDelay().getSeconds())
                .setRollUpColumns(dataFeedRollupSettings.getAutoRollupGroupByColumnNames())
                .setRollUpMethod(RollUpMethod.fromString(dataFeedRollupSettings
                        .getDataFeedAutoRollUpMethod() == null
                        ? null : dataFeedRollupSettings.getDataFeedAutoRollUpMethod().toString()))
                .setNeedRollup(NeedRollupEnum.fromString(dataFeedRollupSettings.getRollupType() == null
                        ? null : dataFeedRollupSettings.getRollupType().toString()))
                .setAllUpIdentification(dataFeedRollupSettings.getRollupIdentificationValue())
                .setFillMissingPointType(FillMissingPointType.fromString(
                        dataFeedMissingDataPointFillSettings.getFillType() == null
                                ? null : dataFeedMissingDataPointFillSettings.getFillType().toString()))
                .setFillMissingPointValue(dataFeedMissingDataPointFillSettings.getCustomFillValue())
                .setViewMode(ViewMode.fromString(finalDataFeedOptions.getAccessMode() == null
                        ? null : finalDataFeedOptions.getAccessMode().toString()))
                .setViewers(finalDataFeedOptions.getViewers())
                .setAdmins(finalDataFeedOptions.getAdmins())
                .setActionLinkTemplate(finalDataFeedOptions.getActionLinkTemplate());

        BinaryData body = BinaryData.fromObject(dataFeedDetail);
        RequestOptions requestOptions = new RequestOptions();
//        requestOptions.setContext(withTracing);

        return this.createDataFeedWithResponse(body, requestOptions).flatMap(createDataFeedResponse -> {
            final String dataFeedId =
                    parseOperationId(createDataFeedResponse.getHeaders().getValue("Location"));
            return getDataFeedWithResponse(dataFeedId);
        });
    }

    /**
     * Get a data feed by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Secondly/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param dataFeedId     The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return a data feed by its id along with {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDataFeedByIdWithResponse(String dataFeedId, RequestOptions requestOptions) {
        return this.serviceClient.getDataFeedByIdWithResponseAsync(dataFeedId, requestOptions).onErrorMap(throwable -> {
            if (throwable instanceof HttpResponseException) {
                MetricsAdvisorError error = BinaryData.fromObject(((HttpResponseException) throwable).getValue()).toObject(MetricsAdvisorError.class);
                return new MetricsAdvisorResponseException(throwable.getMessage(), ((HttpResponseException) throwable).getResponse(), error);
            } else {
                return throwable;
            }
        });
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeed>> getDataFeedWithResponse(String dataFeedId) {
        try {
            return withContext(context -> getDataFeedWithResponse(dataFeedId, context));
        } catch (RuntimeException ex) {
            return monoError(logger, ex);
        }
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeed> getDataFeed(String dataFeedId) {
        return getDataFeedWithResponse(dataFeedId).flatMap(FluxUtil::toMono);
    }

    Mono<Response<DataFeed>> getDataFeedWithResponse(String dataFeedId, Context context) {
        Objects.requireNonNull(dataFeedId, "'dataFeedId' cannot be null.");

        RequestOptions requestOptions = new RequestOptions();
        requestOptions.setContext(context);

        UUID.fromString(dataFeedId);
        return this.getDataFeedByIdWithResponse(dataFeedId, requestOptions).map(response -> {
            DataFeedDetail dataFeedDetail = response.getValue().toObject(DataFeedDetail.class);
            return new SimpleResponse<>(response, DataFeedTransforms.fromInner(dataFeedDetail));
        });
    }

    /**
     * Update a data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     status: String(Active/Paused)
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param dataFeedId     The data feed unique id.
     * @param body           parameters to update a data feed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateDataFeedWithResponse(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.updateDataFeedWithResponseAsync(dataFeedId, body, requestOptions).onErrorMap(throwable -> {
            if (throwable instanceof HttpResponseException) {
                MetricsAdvisorError error = BinaryData.fromObject(((HttpResponseException) throwable).getValue()).toObject(MetricsAdvisorError.class);
                return new MetricsAdvisorResponseException(throwable.getMessage(), ((HttpResponseException) throwable).getResponse(), error);
            } else {
                return throwable;
            }
        });
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeed> updateDataFeed(DataFeed dataFeed) {
        return updateDataFeedWithResponse(dataFeed).flatMap(FluxUtil::toMono);
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeed>> updateDataFeedWithResponse(DataFeed dataFeed) {
        try {
            return withContext(context -> updateDataFeedWithResponse(dataFeed, context));
        } catch (RuntimeException ex) {
            return monoError(logger, ex);
        }
    }

    Mono<Response<DataFeed>> updateDataFeedWithResponse(DataFeed dataFeed, Context context) {

        final DataFeedIngestionSettings dataFeedIngestionSettings = dataFeed.getIngestionSettings();
        final DataFeedOptions dataFeedOptions = dataFeed.getOptions() == null
                ? new DataFeedOptions() : dataFeed.getOptions();
        final DataFeedRollupSettings dataFeedRollupSettings = dataFeedOptions.getRollupSettings() == null
                ? new DataFeedRollupSettings() : dataFeedOptions.getRollupSettings();
        final DataFeedMissingDataPointFillSettings dataFeedMissingDataPointFillSettings =
                dataFeedOptions.getMissingDataPointFillSettings() == null
                        ? new DataFeedMissingDataPointFillSettings() : dataFeedOptions.getMissingDataPointFillSettings();
        final Context withTracing = context.addData(AZ_TRACING_NAMESPACE_KEY, METRICS_ADVISOR_TRACING_NAMESPACE_VALUE);

        DataFeedDetailPatch dataFeedDetailPatch =
                DataFeedTransforms.toInnerForUpdate(dataFeed.getSource())
                        .setDataFeedName(dataFeed.getName())
                        .setDataFeedDescription(dataFeedOptions.getDescription())
                        .setTimestampColumn(dataFeed.getSchema() == null
                                ? null : dataFeed.getSchema().getTimestampColumn())
                        .setDataStartFrom(dataFeed.getIngestionSettings().getIngestionStartTime())
                        .setStartOffsetInSeconds(dataFeedIngestionSettings.getIngestionStartOffset() == null
                                ? null : dataFeedIngestionSettings.getIngestionStartOffset().getSeconds())
                        .setMaxConcurrency(dataFeedIngestionSettings.getDataSourceRequestConcurrency())
                        .setStopRetryAfterInSeconds(dataFeedIngestionSettings.getStopRetryAfter() == null
                                ? null : dataFeedIngestionSettings.getStopRetryAfter().getSeconds())
                        .setMinRetryIntervalInSeconds(dataFeedIngestionSettings.getIngestionRetryDelay() == null
                                ? null : dataFeedIngestionSettings.getIngestionRetryDelay().getSeconds())
                        .setNeedRollup(
                                dataFeedRollupSettings.getRollupType() != null
                                        ? NeedRollupEnum.fromString(dataFeedRollupSettings.getRollupType().toString())
                                        : null)
                        .setRollUpColumns(dataFeedRollupSettings.getAutoRollupGroupByColumnNames())
                        .setRollUpMethod(
                                dataFeedRollupSettings.getDataFeedAutoRollUpMethod() != null
                                        ? RollUpMethod.fromString(
                                        dataFeedRollupSettings.getDataFeedAutoRollUpMethod().toString())
                                        : null)
                        .setAllUpIdentification(dataFeedRollupSettings.getRollupIdentificationValue())
                        .setFillMissingPointType(
                                dataFeedMissingDataPointFillSettings.getFillType() != null
                                        ? FillMissingPointType.fromString(
                                        dataFeedMissingDataPointFillSettings.getFillType().toString())
                                        : null)
                        .setFillMissingPointValue(
                                // For PATCH send 'fill-custom-value' over wire only for 'fill-custom-type'.
                                dataFeedMissingDataPointFillSettings.getFillType() ==
                                        DataFeedMissingDataPointFillType.CUSTOM_VALUE
                                        ? dataFeedMissingDataPointFillSettings.getCustomFillValue()
                                        : null)
                        .setViewMode(
                                dataFeedOptions.getAccessMode() != null
                                        ? ViewMode.fromString(dataFeedOptions.getAccessMode().toString())
                                        : null)
                        .setViewers(dataFeedOptions.getViewers())
                        .setAdmins(dataFeedOptions.getAdmins())
                        .setStatus(
                                dataFeed.getStatus() != null
                                        ? EntityStatus.fromString(dataFeed.getStatus().toString())
                                        : null)
                        .setActionLinkTemplate(dataFeedOptions.getActionLinkTemplate());

        BinaryData body = BinaryData.fromObject(dataFeedDetailPatch);
        RequestOptions requestOptions = new RequestOptions();
//        requestOptions.setContext(withTracing);

        return this.updateDataFeedWithResponse(dataFeed.getId(), body, requestOptions).flatMap(updateDataFeedResponse -> {
            final String dataFeedId = dataFeed.getId();
            return getDataFeedWithResponse(dataFeedId);
        }).map(test -> test);

    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId     The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDataFeedWithResponse(String dataFeedId, RequestOptions requestOptions) {
        return this.serviceClient.deleteDataFeedWithResponseAsync(dataFeedId, requestOptions).onErrorMap(throwable -> {
            if (throwable instanceof HttpResponseException) {
                MetricsAdvisorError error = BinaryData.fromObject(((HttpResponseException) throwable).getValue()).toObject(MetricsAdvisorError.class);
                return new MetricsAdvisorResponseException(throwable.getMessage(), ((HttpResponseException) throwable).getResponse(), error);
            } else {
                return throwable;
            }
        });
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteDataFeed(String dataFeedId) {
        return deleteDataFeedWithResponse(dataFeedId).flatMap(FluxUtil::toMono);
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDataFeedWithResponse(String dataFeedId) {
        try {
            return withContext(context -> deleteDataFeedWithResponse(dataFeedId, context));
        } catch (RuntimeException ex) {
            return monoError(logger, ex);
        }
    }

    Mono<Response<Void>> deleteDataFeedWithResponse(String dataFeedId, Context context) {
        Objects.requireNonNull(dataFeedId, "'dataFeedId' cannot be null.");
        UUID.fromString(dataFeedId);
        RequestOptions requestOptions = new RequestOptions();
        requestOptions.setContext(context);
        return this.deleteDataFeedWithResponse(dataFeedId, requestOptions)
                .map(response -> new SimpleResponse<>(response, null));
    }

    /**
     * Get a metric feedback by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     feedbackId: String
     *     createdTime: String
     *     userPrincipal: String
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param feedbackId     the unique feedback ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return a metric feedback by its id along with {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricFeedbackWithResponse(String feedbackId, RequestOptions requestOptions) {
        return this.serviceClient.getMetricFeedbackWithResponseAsync(feedbackId, requestOptions);
    }

    /**
     * List feedback on the given metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     *     feedbackType: String(Anomaly/ChangePoint/Period/Comment)
     *     startTime: String
     *     endTime: String
     *     timeMode: String(MetricTimestamp/FeedbackCreatedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             feedbackId: String
     *             createdTime: String
     *             userPrincipal: String
     *             metricId: String
     *             dimensionFilter: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body           metric feedback filter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listMetricFeedbacks(BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.listMetricFeedbacksAsync(body, requestOptions);
    }

    /**
     * Create a new metric feedback.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     feedbackId: String
     *     createdTime: String
     *     userPrincipal: String
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param body           metric feedback.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createMetricFeedbackWithResponse(BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.createMetricFeedbackWithResponseAsync(body, requestOptions);
    }

    /**
     * List all hooks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>hookName</td><td>String</td><td>No</td><td>filter hook by its name</td></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             hookId: String
     *             hookName: String
     *             description: String
     *             externalLink: String
     *             admins: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listHooks(RequestOptions requestOptions) {
        return this.serviceClient.listHooksAsync(requestOptions);
    }

    /**
     * Create a new hook.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param body           Create hook request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createHookWithResponse(BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.createHookWithResponseAsync(body, requestOptions);
    }

    /**
     * Get a hook by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param hookId         Hook unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return a hook by its id along with {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getHookWithResponse(String hookId, RequestOptions requestOptions) {
        return this.serviceClient.getHookWithResponseAsync(hookId, requestOptions);
    }

    /**
     * Update a hook.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param hookId         Hook unique ID.
     * @param body           Update hook request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateHookWithResponse(String hookId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.updateHookWithResponseAsync(hookId, body, requestOptions);
    }

    /**
     * Delete a hook.
     *
     * @param hookId         Hook unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteHookWithResponse(String hookId, RequestOptions requestOptions) {
        return this.serviceClient.deleteHookWithResponseAsync(hookId, requestOptions);
    }

    /**
     * Get data ingestion status by data feed.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String(NotStarted/Scheduled/Running/Succeeded/Failed/NoData/Error/Paused)
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param dataFeedId     The data feed unique id.
     * @param body           The query time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return data ingestion status by data feed as paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getDataFeedIngestionStatus(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.getDataFeedIngestionStatusAsync(dataFeedId, body, requestOptions);
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * @param dataFeedId     The data feed unique id.
     * @param body           The backfill time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> resetDataFeedIngestionStatusWithResponse(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.resetDataFeedIngestionStatusWithResponseAsync(dataFeedId, body, requestOptions);
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     latestSuccessTimestamp: String
     *     latestActiveTimestamp: String
     * }
     * }</pre>
     *
     * @param dataFeedId     The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return data last success ingestion job timestamp by data feed along with {@link Response} on successful
     * completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getIngestionProgressWithResponse(
            String dataFeedId, RequestOptions requestOptions) {
        return this.serviceClient.getIngestionProgressWithResponseAsync(dataFeedId, requestOptions);
    }

    /**
     * Get time series data from metric.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     series: [
     *         {
     *             String: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: {
     *                 metricId: String
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             timestampList: [
     *                 String
     *             ]
     *             valueList: [
     *                 double
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId       metric unique id.
     * @param body           query time series data condition.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return time series data from metric along with {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricDataWithResponse(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.getMetricDataWithResponseAsync(metricId, body, requestOptions);
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     activeSince: String
     *     dimensionFilter: {
     *         String: [
     *             String
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId       metric unique id.
     * @param body           filter to query series.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getMetricSeries(String metricId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.getMetricSeriesAsync(metricId, body, requestOptions);
    }

    /**
     * List dimension from certain metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dimensionName: String
     *     dimensionValueFilter: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param metricId       metric unique id.
     * @param body           query dimension option.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getMetricDimension(String metricId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.getMetricDimensionAsync(metricId, body, requestOptions);
    }

    /**
     * Query all anomaly detection configurations for specific metric.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             name: String
     *             description: String
     *             metricId: String
     *             wholeMetricConfiguration: {
     *                 conditionOperator: String(AND/OR)
     *                 smartDetectionCondition: {
     *                     sensitivity: double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: {
     *                         minNumber: int
     *                         minRatio: double
     *                     }
     *                 }
     *                 hardThresholdCondition: {
     *                     lowerBound: Double
     *                     upperBound: Double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *                 changeThresholdCondition: {
     *                     changePercentage: double
     *                     shiftPoint: int
     *                     withinRange: boolean
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *             }
     *             dimensionGroupOverrideConfigurations: [
     *                 {
     *                     group: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *             seriesOverrideConfigurations: [
     *                 {
     *                     series: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId       metric unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAnomalyDetectionConfigurationsByMetricWithResponse(
            String metricId, RequestOptions requestOptions) {
        return this.serviceClient.getAnomalyDetectionConfigurationsByMetricWithResponseAsync(metricId, requestOptions);
    }

    /**
     * Query anomaly detection status.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId       metric unique id.
     * @param body           query options.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return the paginated response with {@link PagedFlux}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getEnrichmentStatusByMetric(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return this.serviceClient.getEnrichmentStatusByMetricAsync(metricId, body, requestOptions);
    }
}
